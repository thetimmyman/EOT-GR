# EOT Guild Raid Dashboard - Project Knowledge Base

## Project Overview
Next.js 14 dashboard application for analyzing guild raid performance data from the mobile game "Eternal Odyssey Tale" (EOT). The application displays player statistics, boss performance metrics, and raid analytics.

## Tech Stack
- **Framework**: Next.js 14 (App Router)
- **Language**: TypeScript
- **Database**: Supabase (PostgreSQL)
- **Charts**: Recharts v3.1.0
- **Styling**: Tailwind CSS
- **Hosting**: GitHub Codespaces

## Database Schema
**Main Table**: `EOT_GR_data`

Key fields:
- `Guild`: Guild identifier (e.g., 'IW')
- `Season`: Season number (string)
- `displayName`: Player display name
- `Name`: Enemy/boss name
- `damageDealt`: Damage dealt by player
- `damageType`: Type of damage (e.g., 'attack', 'bomb')
- `loopIndex`: Raid loop/lap number
- `tier`: Boss tier level (1-5)
- `enemyHp`: Total enemy HP
- `enemyHpLeft`: Remaining enemy HP
- `encounterId`: Unique encounter identifier
- `timestamp`: Action timestamp
- `startedOn`: Encounter start time
- `completedOn`: Encounter completion time

## Architecture

### Pages/Components
- `page.tsx`: Main dashboard with navigation
- `SummaryPage.tsx`: Overview statistics and charts
- `PlayerPerformancePage.tsx`: Individual player analytics
- `BossPerformancePage.tsx`: Boss-specific performance metrics
- `L1BossPage.tsx` to `L5BossPage.tsx`: Tier-specific boss pages
- `TokenUsagePage.tsx`: Token usage analytics
- `VOTLWPage.tsx`: Victory over the Last Week metrics
- `DebugPage.tsx`: Database connection testing

### Key Components
- `Navigation.tsx`: Main navigation bar
- `RechartsWrapper.tsx`: Type-safe wrapper for recharts components

## Known Issues & Solutions

### TypeScript/Recharts Compatibility
**Issue**: Recharts v3.1.0 bundles React 19 types, conflicting with project's React 18 types
**Solution**: 
- Use `RechartsWrapper.tsx` for type-safe imports
- Added package.json overrides to force React 18 types
- Updated tsconfig.json with path mappings

### Common Build Commands
```bash
npm run dev          # Development server
npm run build        # Production build
npm run lint         # ESLint check
npm run typecheck    # TypeScript check (if available)
```

### Database Connection
- Uses Supabase client with anon key
- Connection test on app startup
- Automatically detects available seasons (70-80 range)

## Data Analysis Patterns

### Player Performance Metrics
- Average damage per encounter
- Total damage dealt
- Token efficiency
- Biggest single hit
- Hit count and accuracy

### Boss Performance Tracking
- Damage distribution across tiers
- Loop/lap progression
- Token usage per boss
- Time-based performance trends

### Guild Analytics
- Season-over-season comparisons
- Player rankings
- Resource utilization
- Victory rates

## Common Queries
- Season data: Filter by `Season` field
- Guild data: Filter by `Guild` field
- Player stats: Group by `displayName`
- Boss encounters: Filter by `Name` and `tier`
- Token usage: Count records per player per loop

## Development Notes
- All components use 'use client' directive
- Supabase queries should handle null/undefined values
- Chart components need proper TypeScript typing
- Loading states important for UX

## Troubleshooting
- If charts don't render: Check RechartsWrapper imports
- If build fails: Run `npm run build` to see TypeScript errors
- If database connection fails: Check Supabase client configuration
- If port forwarding issues: Ensure dev server is running on correct port

---
*Last updated: Auto-generated by Claude Code*

## Environment Configuration

### Required Environment Variables

Create a `.env.local` file with the following variables:

```bash
# Supabase Configuration
NEXT_PUBLIC_SUPABASE_URL=your_supabase_url
NEXT_PUBLIC_SUPABASE_ANON_KEY=your_supabase_anon_key
```

### External API Integration

The application can be extended to integrate with external APIs for data synchronization. Refer to your game's API documentation for specific endpoints and authentication requirements.

## PowerBI Information

We have been using PowerBI to do all of our data analysis. The below query was used to pull data from Supabase, transform the data, create calculated columns and dax measures.

## PowerBI Query

let
    // Function to fetch a page of data with pagination
    FetchDataWithPagination = (maxPages) => 
        let
            // Inner function to recursively fetch pages
            FetchPages = (currentPage, accumulator) =>
                let
                    // Calculate offset
                    offset = currentPage * 1000,
                    
                    // Fetch the current page from EOT_GR_data
                    currentData = Json.Document(Web.Contents(
                        "https://ctzowkkbsnztaojllwta.supabase.co/rest/v1/EOT_GR_data?select=*&limit=1000&offset=" & Text.From(offset),
                        [Headers=[
                            apikey="eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImN0em93a2tic256dGFvamxsd3RhIiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTc0MzUyMjYxMiwiZXhwIjoyMDU5MDk4NjEyfQ.KtK-7SsbkEAICrKYh97Me_qzhV-PLVirG6SQEYcMX5k",
                            Authorization="Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImN0em93a2tic256dGFvamxsd3RhIiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTc0MzUyMjYxMiwiZXhwIjoyMDU5MDk4NjEyfQ.KtK-7SsbkEAICrKYh97Me_qzhV-PLVirG6SQEYcMX5k",
                            Prefer="return=representation"
                        ]]
                    )),
                    
                    // Combine with accumulated data
                    newAccumulator = List.Combine({accumulator, currentData}),
                    
                    // Check if we should continue
                    shouldContinue = List.Count(currentData) = 1000 and currentPage < maxPages - 1
                in
                    if shouldContinue then
                        @FetchPages(currentPage + 1, newAccumulator)
                    else
                        newAccumulator
        in
            FetchPages(0, {}),
    
    // Fetch all data with pagination
    AllData = FetchDataWithPagination(1000),
    
    // Process the combined data
    #"Converted to Table" = Table.FromList(AllData, Splitter.SplitByNothing(), null, null, ExtraValues.Error),
    #"Expanded Column1" = Table.ExpandRecordColumn(#"Converted to Table", "Column1", {"id", "Guild", "Season", "displayName", "Name", "enemyHp", "enemyHpLeft", "damageType", "damageDealt", "loopIndex", "tier", "set", "encounterId", "startedOn", "completedOn", "timestamp", "rarity", "userId", "encounterIndex", "encounterType", "globalConfigHash", "heroDetails", "machineOfWarDetails", "remainingHp", "unitId", "type", "maxHp"}, {"id", "Guild", "Season", "displayName", "Name", "enemyHp", "enemyHpLeft", "damageType", "damageDealt", "loopIndex", "tier", "set", "encounterId", "startedOn", "completedOn", "timestamp", "rarity", "userId", "encounterIndex", "encounterType", "globalConfigHash", "heroDetails", "machineOfWarDetails", "remainingHp", "unitId", "type", "maxHp"}),
    
    // CRITICAL: Replace nulls in NOT NULL fields BEFORE type conversion
    #"Replaced Nulls" = Table.TransformColumns(#"Expanded Column1", {
        {"encounterId", each if _ = null then 0 else _},
        {"encounterIndex", each if _ = null then 0 else _},
        {"Guild", each if _ = null then "Unknown" else _},
        {"enemyHp", each if _ = null then 0 else _},
        {"enemyHpLeft", each if _ = null then 0 else _},
        {"damageDealt", each if _ = null then 0 else _},
        {"loopIndex", each if _ = null then 0 else _},
        {"tier", each if _ = null then 0 else _},
        {"remainingHp", each if _ = null then 0 else _},
        {"maxHp", each if _ = null then 0 else _}
    }),
    
    // Now apply type conversions on cleaned data
    #"Changed Type" = Table.TransformColumnTypes(#"Replaced Nulls",{
        {"id", Int64.Type}, 
        {"Guild", type text}, 
        {"Season", type text}, 
        {"displayName", type text}, 
        {"Name", type text}, 
        {"enemyHp", Int64.Type}, 
        {"enemyHpLeft", Int64.Type}, 
        {"damageType", type text}, 
        {"damageDealt", Int64.Type}, 
        {"loopIndex", Int64.Type}, 
        {"tier", Int64.Type}, 
        {"set", type text}, 
        {"encounterId", Int64.Type},
        {"startedOn", type datetime}, 
        {"completedOn", type datetime}, 
        {"timestamp", type datetime},
        {"rarity", type text},
        {"userId", type text},
        {"encounterIndex", Int64.Type},
        {"encounterType", type text},
        {"globalConfigHash", type text},
        {"heroDetails", type text},
        {"machineOfWarDetails", type text},
        {"remainingHp", Int64.Type},
        {"unitId", type text},
        {"type", type text},
        {"maxHp", Int64.Type}
    }),
    
    // Sort by startedOn date in descending order
    #"Sorted Rows" = Table.Sort(#"Changed Type",{{"startedOn", Order.Descending}}),
    
    // ADD INDEX EARLY (blastinator's optimization)
    #"Added Index" = Table.AddIndexColumn(#"Sorted Rows", "Index", 0, 1, Int64.Type),
    
    // Group by Guild/Season/loopIndex/Name
    #"Grouped Rows" = Table.Group(#"Added Index", {"Guild", "Season", "loopIndex", "Name"}, {{"BossLoopIndex", each _, type table}}),
    
    #"Added Custom" = Table.AddColumn(#"Grouped Rows", "Custom", each Table.AddIndexColumn([BossLoopIndex],"Index_SeasonLoopBoss", 0,1)),
    
    #"Removed Other Columns" = Table.SelectColumns(#"Added Custom",{"Custom"}),
    
    // Expanded Custom with all fields
    #"Expanded Custom" = Table.ExpandTableColumn(#"Removed Other Columns", "Custom", 
        {"Guild", "Season", "displayName", "Name", "enemyHp", "enemyHpLeft", "damageType", "damageDealt", "loopIndex", "tier", "set", "encounterId", "startedOn", "completedOn", "Index_SeasonLoopBoss", "Index", "rarity", "userId", "encounterIndex", "encounterType", "globalConfigHash", "heroDetails", "machineOfWarDetails", "remainingHp", "unitId", "type", "maxHp"}, 
        {"Guild", "Season", "displayName", "Name", "enemyHp", "enemyHpLeft", "damageType", "damageDealt", "loopIndex", "tier", "set", "encounterId", "startedOn", "completedOn", "Index_SeasonLoopBoss", "Index", "rarity", "userId", "encounterIndex", "encounterType", "globalConfigHash", "heroDetails", "machineOfWarDetails", "remainingHp", "unitId", "type", "maxHp"}),
    
    // Group by Guild/displayName/damageType
    #"Grouped Rows1" = Table.Group(#"Expanded Custom", {"Guild", "displayName", "damageType"}, {{"PlayerTokenIndex", each _, type table}}),
    
    #"Added Custom1" = Table.AddColumn(#"Grouped Rows1", "PlayerTokenInd", each Table.AddIndexColumn([PlayerTokenIndex],"PlayerTokenInd",0,1)),
    
    #"Removed Other Columns1" = Table.SelectColumns(#"Added Custom1",{"PlayerTokenInd"}),
    
    // Expansion with all fields
    #"Expanded PlayerTokenInd" = Table.ExpandTableColumn(#"Removed Other Columns1", "PlayerTokenInd", {"Guild", "Season", "displayName", "Name", "enemyHp", "enemyHpLeft", "damageType", "damageDealt", "loopIndex", "tier", "set", "encounterId", "startedOn", "completedOn", "Index_SeasonLoopBoss", "Index", "PlayerTokenInd", "rarity", "userId", "encounterIndex", "encounterType", "globalConfigHash", "heroDetails", "machineOfWarDetails", "remainingHp", "unitId", "type", "maxHp"}, {"PlayerTokenInd.Guild", "PlayerTokenInd.Season", "PlayerTokenInd.displayName", "PlayerTokenInd.Name", "PlayerTokenInd.enemyHp", "PlayerTokenInd.enemyHpLeft", "PlayerTokenInd.damageType", "PlayerTokenInd.damageDealt", "PlayerTokenInd.loopIndex", "PlayerTokenInd.tier", "PlayerTokenInd.set", "PlayerTokenInd.encounterId", "PlayerTokenInd.startedOn", "PlayerTokenInd.completedOn", "PlayerTokenInd.Index_SeasonLoopBoss", "PlayerTokenInd.Index", "PlayerTokenInd.PlayerTokenInd", "PlayerTokenInd.rarity", "PlayerTokenInd.userId", "PlayerTokenInd.encounterIndex", "PlayerTokenInd.encounterType", "PlayerTokenInd.globalConfigHash", "PlayerTokenInd.heroDetails", "PlayerTokenInd.machineOfWarDetails", "PlayerTokenInd.remainingHp", "PlayerTokenInd.unitId", "PlayerTokenInd.type", "PlayerTokenInd.maxHp"}),
    
    // Rename columns
    #"Renamed Columns" = Table.RenameColumns(#"Expanded PlayerTokenInd",{
        {"PlayerTokenInd.Guild", "Guild"}, 
        {"PlayerTokenInd.PlayerTokenInd", "PlayerTokenInd"}, 
        {"PlayerTokenInd.Season", "Season"}, 
        {"PlayerTokenInd.displayName", "displayName"}, 
        {"PlayerTokenInd.Name", "Name"}, 
        {"PlayerTokenInd.enemyHp", "enemyHp"}, 
        {"PlayerTokenInd.enemyHpLeft", "enemyHpLeft"}, 
        {"PlayerTokenInd.damageType", "damageType"}, 
        {"PlayerTokenInd.damageDealt", "damageDealt"}, 
        {"PlayerTokenInd.loopIndex", "loopIndex"}, 
        {"PlayerTokenInd.tier", "tier"}, 
        {"PlayerTokenInd.set", "set"}, 
        {"PlayerTokenInd.encounterId", "encounterId"}, 
        {"PlayerTokenInd.startedOn", "startedOn"}, 
        {"PlayerTokenInd.completedOn", "completedOn"}, 
        {"PlayerTokenInd.Index_SeasonLoopBoss", "Index_SeasonLoopBoss"}, 
        {"PlayerTokenInd.Index", "Index"},
        {"PlayerTokenInd.rarity", "rarity"},
        {"PlayerTokenInd.userId", "userId"},
        {"PlayerTokenInd.encounterIndex", "encounterIndex"},
        {"PlayerTokenInd.encounterType", "encounterType"},
        {"PlayerTokenInd.globalConfigHash", "globalConfigHash"},
        {"PlayerTokenInd.heroDetails", "heroDetails"},
        {"PlayerTokenInd.machineOfWarDetails", "machineOfWarDetails"},
        {"PlayerTokenInd.remainingHp", "remainingHp"},
        {"PlayerTokenInd.unitId", "unitId"},
        {"PlayerTokenInd.type", "type"},
        {"PlayerTokenInd.maxHp", "maxHp"}
    }),
    
    // Final type check and null replacement for safety
    #"Final Null Check" = Table.TransformColumns(#"Renamed Columns", {
        {"encounterId", each if _ = null then 0 else _},
        {"encounterIndex", each if _ = null then 0 else _}
    }),
    
    #"Changed Type1" = Table.TransformColumnTypes(#"Final Null Check",{{"startedOn", type datetime}, {"completedOn", type datetime}, {"rarity", type text}, {"userId", type text}, {"encounterIndex", Int64.Type}, {"encounterId", Int64.Type}, {"encounterType", type text}, {"globalConfigHash", type text}, {"heroDetails", type text}, {"machineOfWarDetails", type text}, {"remainingHp", Int64.Type}, {"unitId", type text}, {"type", type text}, {"maxHp", Int64.Type}, {"set", Int64.Type}, {"Season", Int64.Type}, {"loopIndex", Int64.Type}, {"damageDealt", Int64.Type}, {"enemyHpLeft", Int64.Type}, {"enemyHp", Int64.Type}, {"tier", Int64.Type}, {"Index_SeasonLoopBoss", Int64.Type}, {"Index", Int64.Type}, {"PlayerTokenInd", Int64.Type}})
in
    #"Changed Type1"


## Power BI DAX Measures

We are re-creating the following DAX measures with this app. Please be aware that some variables used in these calculations are not available in the Supabase data as they were added in PowerBI. We would need to recreate them in this app.

WeightedContribution = 
VAR season = [Season]
VAR boss = [Name]
VAR RMS_PerSeasonPerBoss = 
    CALCULATE(
        SQRT(
            AVERAGEX(
                EOT_GR_data, 
                [damageDealt]^2
            )
        ), 
        FILTER(
            EOT_GR_data, 
            EOT_GR_data[Season] = season 
                && EOT_GR_data[Name] = boss 
                && EOT_GR_data[SpecialCases] <> "Last Hit" 
                && EOT_GR_data[damageType] = "Battle"
        )
    )
VAR SeasonAvg = 
    CALCULATE(
        AVERAGE(EOT_GR_data[damageDealt]), 
        FILTER(
            EOT_GR_data, 
            EOT_GR_data[Season] = season 
                && EOT_GR_data[SpecialCases] <> "Last Hit" 
                && EOT_GR_data[damageType] = "Battle"
        )
    )
VAR WeightValue = IF(RMS_PerSeasonPerBoss = 0, 0.01, (SeasonAvg/RMS_PerSeasonPerBoss) + 0.01)
VAR modifier = 
    IF(
        [SpecialCases] = "Last Hit", 
        1.25, 
        IF(
            [SpecialCases] = "One Shot", 
            1.5, 
            1
        )
    )
VAR result = 
    IF(
        [tier] < 4, 
        SeasonAvg,
        [damageDealt] * WeightValue * modifier
    )
RETURN
    result


SpecialCases = 
VAR __loop = [loopIndex]
VAR __boss = [Name]
VAR __tier = [tier]
VAR __season = [Season]
VAR __current_remainingHp = [remainingHp]

-- Find the minimum remaining HP for this specific boss encounter (the finishing blow)
VAR __min_remainingHp = 
    MINX(
        FILTER(
            'EOT_GR_data',
            'EOT_GR_data'[loopIndex] = __loop &&
            'EOT_GR_data'[Name] = __boss &&
            'EOT_GR_data'[tier] = __tier &&
            'EOT_GR_data'[Season] = __season
        ),
        'EOT_GR_data'[remainingHp]
    )

-- Count total hits for this specific boss encounter
VAR __total_hits = 
    CALCULATE(
        COUNT('EOT_GR_data'[Index]),
        FILTER(
            'EOT_GR_data',
            'EOT_GR_data'[loopIndex] = __loop &&
            'EOT_GR_data'[Name] = __boss &&
            'EOT_GR_data'[tier] = __tier &&
            'EOT_GR_data'[Season] = __season
        )
    )

-- Determine if this is a last hit (minimum remaining HP AND Battle damage type)
VAR __last_hit = 
    IF(
        __current_remainingHp = __min_remainingHp,
        IF([damageType] = "Battle", 1, 0),
        0
    )

-- Determine if this is a one shot (last hit with only 1 total hit)
VAR __one_shot = 
    IF(
        __last_hit = 1,
        IF(__total_hits = 1, 1, 0),
        0
    )

-- Final result logic
VAR __result = 
    IF(
        ISBLANK([damageDealt]),
        "Crash",
        IF(
            __one_shot = 1,
            "One Shot",
            IF(
                __last_hit = 1,
                "Last Hit",
                "Standard"
            )
        )
    )

RETURN __result

playerVsGuildAvg = 
VAR __season = [season]
VAR __boss = [name]
VAR __player = [displayName]
VAR __bossRank = [overallTokenUseage]

// Get current guild from the current row context
VAR __currentGuild = FIRSTNONBLANK('EOT_GR_data'[Guild], 1)

// Calculate average damage for the current guild only
VAR __avgPerSeasonPerBoss = 
    CALCULATE(
        AVERAGE('EOT_GR_data'[damageDealt]),
        FILTER(
            ALLEXCEPT('EOT_GR_data', 'EOT_GR_data'[Guild]),
            'EOT_GR_data'[Guild] = __currentGuild &&
            'EOT_GR_data'[Season] = __season && 
            'EOT_GR_data'[Name] = __boss && 
            'EOT_GR_data'[SpecialCases] <> "Last Hit" && 
            'EOT_GR_data'[damageType] = "Battle" &&
            'EOT_GR_data'[overallTokenUseage] = __bossRank
        )
    )

// Calculate average for this specific player within the same guild
VAR __avgPerSeasonPerBossPerPlayer = 
    CALCULATE(
        AVERAGE('EOT_GR_data'[damageDealt]),
        FILTER(
            ALLEXCEPT('EOT_GR_data', 'EOT_GR_data'[Guild], 'EOT_GR_data'[displayName]),
            'EOT_GR_data'[Guild] = __currentGuild &&
            'EOT_GR_data'[Season] = __season && 
            'EOT_GR_data'[Name] = __boss && 
            'EOT_GR_data'[SpecialCases] <> "Last Hit" && 
            'EOT_GR_data'[displayName] = __player && 
            'EOT_GR_data'[damageType] = "Battle" &&
            'EOT_GR_data'[overallTokenUseage] = __bossRank
        )
    )

// Calculate percentage difference
VAR __vsAvg = 
    IF(
        AND(__avgPerSeasonPerBoss > 0, __avgPerSeasonPerBossPerPlayer > 0),
        DIVIDE(__avgPerSeasonPerBossPerPlayer, __avgPerSeasonPerBoss),
        0
    )
VAR __result = (__vsAvg - 1) * 100

RETURN __result

playerVsAvg = 
VAR __season = [season]
VAR __boss = [name]
VAR __player = [displayName]
VAR __bossRank = [overallTokenUseage]

var __avgPerSeasonPerBoss = 
    calculate(AVERAGE('EOT_GR_data'[damageDealt] ), 
        FILTER(
            'EOT_GR_data', 'EOT_GR_data'[Season] = __season && 
            'EOT_GR_data'[Name] = __boss && 
            'EOT_GR_data'[SpecialCases] <> "Last Hit" && 
            'EOT_GR_data'[damageType] = "Battle" &&
            'EOT_GR_data'[overallTokenUseage] = __bossRank
            )
        )

VAR __avgPerSeasonPerBossPerPlayer = 
    calculate(AVERAGE('EOT_GR_data'[damageDealt] ), 
        FILTER(
            'EOT_GR_data', 'EOT_GR_data'[Season] = __season && 
            'EOT_GR_data'[Name] = __boss && 
            'EOT_GR_data'[SpecialCases] <> "Last Hit" && 
            'EOT_GR_data'[displayName] = __player && 
            'EOT_GR_data'[damageType] = "Battle" &&
            'EOT_GR_data'[overallTokenUseage] = __bossRank
            )
        )

VAR __vsAvg = (__avgPerSeasonPerBossPerPlayer/__avgPerSeasonPerBoss)
VAR __result = (__vsAvg-1)*100

return

__RESULT

contribution = 
VAR __season = [season]
VAR __boss = [name]
VAR __player = [displayName]
var __avgPerSeasonPerBoss = calculate(AVERAGE('EOT_GR_data'[damageDealt] ), FILTER('EOT_GR_data', 'EOT_GR_data'[Season] = __season && 'EOT_GR_data'[Name] = __boss && 'EOT_GR_data'[SpecialCases] <> "Last Hit" && 'EOT_GR_data'[damageType] = "Battle"))
var __SeasonAvg = calculate(AVERAGE('EOT_GR_data'[damageDealt] ), FILTER('EOT_GR_data', 'EOT_GR_data'[Season] = __season && 'EOT_GR_data'[SpecialCases] <> "Last Hit" && 'EOT_GR_data'[damageType] = "Battle"))
var __WEIGHT = (__SeasonAvg/__avgPerSeasonPerBoss)+.01

VAR __result = [damageDealt]*__WEIGHT
return
__RESULT

